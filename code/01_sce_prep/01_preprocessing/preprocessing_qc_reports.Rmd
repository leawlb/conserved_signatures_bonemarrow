---
title: "preprocessing_sample_report"
author: "Amy Danson, Lea WÃ¶lbert"
date: '2022-09-20'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

QC report for all samples separately (Object_ID).
Some operations from the scripts must be repeated to generate relevant plots,
but any new objects cannot be saved from an .Rmd script.
Repeat various steps for visualisation.

#### Load libraries, source code 

```{r seed, message = FALSE}
set.seed(37)
```

```{r load, message = FALSE}
library(SingleCellExperiment, quietly = TRUE) 
library(DropletUtils, quietly = TRUE) 
library(tidyverse, quietly = TRUE) 
library(scater, quietly = TRUE) 
library(scuttle, quietly = TRUE) 
library(scran, quietly = TRUE) 
```

```{r source, message = FALSE}
source(file = snakemake@params[["plotting"]])
```

```{r load_objects, message = FALSE}
# call objects
sce_input <- readRDS(file = snakemake@input[["sce_input"]])
sce_drop <- readRDS(file = snakemake@input[["sce_drop"]])
sce_outl <- readRDS(file = snakemake@input[["sce_outl"]])
sce_norm <- readRDS(file = snakemake@input[["sce_norm"]])
sce_dimr <- readRDS(file = snakemake@input[["sce_dimr"]])

# set name for plots
name_curr <- colData(sce_drop)$Object_ID[1] 
```

```{r declare_cutoffs, message = FALSE}
# call metadata
cutoff_umis <- snakemake@params[["cutoff_umis"]]
cutoff_doublets <- snakemake@params[["cutoff_doublets"]] 
cutoff_sum <- snakemake@params[["cutoff_sum"]] 
cutoff_detected <- snakemake@params[["cutoff_detected"]]
cutoff_mitos <- snakemake@params[["cutoff_mitos"]]
```

```{r colors, message = FALSE}
source(file = snakemake@params[["colors"]])
```

## Step 1: 

### Remove empty droplets

Check that the barcode rank and p value distributions look appropriate.
Also check if any droplets with low FDR (that are likely cells) were dropped

```{r}

# show barcoded ranks 
bcrank <- barcodeRanks(counts(sce_input)) #before droplet removal
uniq_pos <- !duplicated(bcrank$rank)

plot(bcrank$rank[uniq_pos], bcrank$total[uniq_pos], log="xy", 
     xlab="Rank", ylab="Total UMI count", cex.lab=1.2, main = name_curr)
  abline(h=metadata(bcrank)$inflection, col = marker1)
  abline(h=metadata(bcrank)$knee, col = marker2)
  legend("bottomleft", legend=c("Inflection", "Knee"), 
         col=c(marker1, marker2), cex=1.2)

# show pval distribution    
cutoff_umis <- cutoff_umis
out <- emptyDrops(counts(sce_input), lower = cutoff_umis, test.ambient=TRUE)  

hist(out$PValue[out$Total <= cutoff_umis & out$Total > 0],
     xlab="P-value",
     main = paste(name_curr, "cutoff", cutoff_umis), col="grey80")  

# show FDR of droplets that were kept or removed
check <- table(Sig=out$FDR <= 0.001, Limited=out$Limited)
print(check)
```

### Remove doublets

Check if cells with high doublet scores form conspicuous clusters

```{r}
plotUMAP(sce_dimr, colour_by = "doublet_score")+ # requires reduced dims
  ggtitle(name_curr)+
  theme(legend.key.size = unit(0.3, "cm"), legend.key.width = unit(0.3, "cm"))+
  theme(legend.spacing = unit(0.06, "cm"), legend.text = element_text(size = 7))
```

## Step 2: Remove outliers

Check the quality of the single cells and if cells were removed appropriately

```{r}

# get mito count just to check
mito_genes <- grep("mt-", rownames(sce_drop))
qcdf_outl <- perCellQCMetrics(sce_drop, subsets=list(Mito=mito_genes)) 
# before outlier removal

# set QC cutoffs below which cells are removed
sum_out <- qcdf_outl$sum < cutoff_sum 
det_out <- qcdf_outl$detected < cutoff_detected 
mito_out <- qcdf_outl$subsets_Mito_percent > cutoff_mitos

# remove all cells to discard and add info to qc
remove_pos <- sum_out | det_out | mito_out
qcdf_outl$removed <- remove_pos

qcdf_gg <- as.data.frame(qcdf_outl[,c(1,2,5,7)])

qcdf_gg <- pivot_longer(qcdf_gg, 
                        names_to = "metric", cols = c(1, 2, 3))

ggplot(qcdf_gg[qcdf_gg$metric == "sum",], aes(y = value, x = metric, 
                                              color = removed))+
  theme_classic()+
  geom_jitter(size = 0.1, alpha = 50)+
  geom_violin(color = "black", alpha = 0, draw_quantiles = 0.5)+  
  scale_color_manual("Removed", values = c("FALSE" = "grey80", 
                                           "TRUE" = "orange"))+
  ylab("Library size")+
  ggtitle(name_curr)+
  theme(axis.title.x = element_blank(), axis.text.x = element_blank())+
  geom_abline(intercept = cutoff_sum, color = marker1,  slope = 0) 

ggplot(qcdf_gg[qcdf_gg$metric == "detected",], aes(y = value, x = metric,
                                                   color = removed))+
  theme_classic()+
  geom_jitter(size = 0.1, alpha = 50)+
  geom_violin(color = "black", alpha = 0, draw_quantiles = 0.5)+ 
  scale_color_manual("Removed", values = c("FALSE" = "grey80", 
                                           "TRUE" = "orange"))+
  ylab("Detected genes")+
  ggtitle(name_curr)+
  theme(axis.title.x = element_blank(), axis.text.x = element_blank())+
  geom_abline(intercept = cutoff_detected, color = marker1, slope = 0) 

ggplot(qcdf_gg[qcdf_gg$metric == "subsets_Mito_percent",], 
       aes(y = value, x = metric, color = removed))+
  theme_classic()+
  geom_jitter(size = 0.1, alpha = 50)+
  geom_violin(color = "black", alpha = 0, draw_quantiles = 0.5)+  
  scale_color_manual("Removed", values = c("FALSE" = "grey80", 
                                           "TRUE" = "orange"))+
  ylab("Mitochondrial gene percent")+
  ggtitle(name_curr)+
  theme(axis.title.x = element_blank(), axis.text.x = element_blank())+
  geom_abline(intercept = cutoff_mitos, color = marker1, slope = 0) 
```

## Step 3: Normalization

```{r}
# calculate two different size factors for direct comparison
quick_clust <- quickCluster(sce_outl) # before normalization
sizef_deconv <- calculateSumFactors(sce_outl, cluster = quick_clust)
sizef_lib <- librarySizeFactors(sce_outl)

plot(sizef_lib, sizef_deconv, xlab = "Library size factor",
    ylab = "Deconv. size factor", log = 'xy', pch=16, 
    main = paste("Library/Deconv", name_curr))
    abline(a=0, b=1, col="red")
    
# distribution of size factors should be close to normal dist
hist(log10(sizef_deconv), xlab="Log10[Deconv factor]", col='grey80', 
     main = name_curr)
    
# directly compare deconv factors to library size
qcdf_03 <- perCellQCMetrics(sce_outl) # after outlier removal
plot(sizef_deconv, qcdf_03$sum, log = "xy", ylab = "Library size",
     xlab = "Deconv. Size factor", main = paste("Deconv/libsize", name_curr))
```

```{r}
# print final object
print(name_curr)
print(sce_norm) # after normalization
print(colData(sce_norm))
print(ncol(sce_norm))
```

## Remaining quality

```{r}

qcdf_dimr <- perCellQCMetrics(sce_dimr)
sce_dimr$sum <- qcdf_dimr$sum
sce_dimr$detected <- qcdf_dimr$detected

plot_1 <- umap_base(sce_dimr, color_by = "sum")+
  scale_color_gradientn("Library size", 
                         limits = c(0, 100000),
                         colors = c("black", "darkorange4", "darkorange3",
                                    "darkorange1",
                                    "orange", "orange", "gold1", "gold",
                                    "lightgoldenrod", "lightgoldenrod", 
                                    "lightgoldenrod", "lightgoldenrod", 
                                    "lightgoldenrod", "lightgoldenrod"))+
  ggtitle(name_curr)
plot_1l <- umap_legend(sce_dimr, color_by = "sum")+
  scale_color_gradientn("Library size", 
                         limits = c(0, 1000000),
                          colors = c("black", "darkorange4", "darkorange3", 
                                     "darkorange1",
                                    "orange", "orange", "gold1", "gold",
                                    "lightgoldenrod", "lightgoldenrod", 
                                    "lightgoldenrod", "lightgoldenrod", 
                                    "lightgoldenrod", "lightgoldenrod"))
legend_1 <- get_legend(plot_1l)

PLOT_1 <- ggarrange(plot_1, legend_1)
PLOT_1

plot_2 <- umap_base(sce_dimr, color_by = "detected")+
  scale_color_gradientn("Number of detected genes", 
                         limits = c(0, 10000),
                         colors = c("black", "darkorange3", "orange", 
                                    "lightgoldenrod"))+
  ggtitle(name_curr)
plot_2l <- umap_legend(sce_dimr, color_by = "detected")+
  scale_color_gradientn("Number of detected genes", 
                         limits = c(0, 10000),
                         colors = c("black", "darkorange3", "orange", 
                                    "lightgoldenrod"))
legend_2 <- get_legend(plot_2l)

PLOT_2 <- ggarrange(plot_2, legend_2)
PLOT_2
```

```{r}
sessionInfo()
```