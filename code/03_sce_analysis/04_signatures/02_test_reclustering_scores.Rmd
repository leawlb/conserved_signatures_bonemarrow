---
title: "Report on testing different reclustering scores"
author: "Lea WÃ¶lbert"
date: '2024-08-12'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

In order to evaluate re-clustering of datasets using different sets of genes,
we evaluate which metrics to compare two clusterings are suitable.
For example, we look for scores that do not change much with different
resolutions/nr of clusters.

#### Load objects

```{r seed, message = FALSE}
set.seed(37)
```

```{r load, message = FALSE}
library(mclust, quietly = TRUE)
library(bluster, quietly = TRUE)
library(cluster, quietly = TRUE)
library(Seurat, quietly = TRUE)
library(ggplot2, quietly = TRUE)
```

```{r load_object}
seu_list_all <- base::readRDS(snakemake@input[["seu_list"]])
dataset_curr <- snakemake@wildcards[["dataset"]]
```

```{r source}
source(file = snakemake@params[["reclustering_functions"]])
```

```{r colors}
# put into colors.txt once more established
col_vec_cons <- c("conserved_signature" = "yellowgreen",
                  "conserved_markers" = "darkgreen",
                  "mmusall_markers" = "blue2",
                  "random_features" = "purple2")

col_vec1 <- c("prop_of_zeros" = "goldenrod1",
              "mean_ct_per_cluster_norm" = "indianred1",
              "prop_cells_per_cluster_median" = "steelblue4",
              "prop_cells_per_cluster_mean" = "steelblue1",
              "prop_cells_per_cluster_mean_ranked" = "lightblue3")
  
col_vec2 <- c("mean_ct_per_cluster" = "indianred3",
              "mean_cluster_per_ct" = "seagreen2",
              "total_nr_cluster" = "seagreen4")

col_vec3 <- c("median_silhouette_width" = "goldenrod4",
              "mean_silhouette_width" = "goldenrod2",
              "median_purity" = "olivedrab4",
              "mean_purity" = "olivedrab2")

col_vec4 <-  c("adj_rand" = "orchid",
               "fowlkes_mallows" = "darkblue",
               "variation_information" = "orange")
```

```{r}
nr_celltypes <- length(base::unique(seu_list_all$seu_sign[[1]]$cell_type))
print(nr_celltypes)
cut_off_ranks <- 0.15
```


## Functions

### Scores using a comparison matrix

Using a comparison matrix of this format:

```{r fig.width = 4, fig.height = 4}
df_ex <- base::data.frame("cluster" = c("cluster1", "cluster2",
                                        "cluster3", "cluster4"),
                          "ct1" = c(0.5, 0, 0.33, 0),
                          "ct2" = c(0.5, 0, 0.33, 0),
                          "ct3" = c(0, 1, 0.33, 1))

print(df_ex)

df_ex <- tidyr::pivot_longer(df_ex, c(2:4),
                             values_to = "value", 
                             names_to = "celltype")
ggplot2::ggplot(df_ex, aes(x = celltype, y = cluster, fill = value))+
  ggplot2::geom_tile()+
  ggplot2::theme_minimal()+
  ggplot2::scale_fill_continuous("% cells/cluster", 
                        limits=c(0, 1), 
                        breaks=c(0, 0.5, 1),
                        low = "white", high = "blue")+
  ggplot2::theme(legend.position = "bottom")
```

with the values indicating the proportion of cells of a given cell type ct
per cluster cl.

- prop_of_zeros = the proportion of fields that is 0 divided by the number of 
  fields that could be 0 in an optimal reclustering.
  This is the total nr of cell types multiplied with the total nr of clusters, 
  divided by the larger of the two.
  is larger.
  In the upper example, the score would be 5/(12-4) = 0.625
  
- mean_ct_per_cluster_norm = the total number of different cell types detected
  per cluster. As a score, the mean is calculated, then normalized to the 
  absolute number of cell types in the dataset.
  Is in some ways roughly a reverse metric of prop_of_zeros.
  Does not really require a comparison matrix.
  In the upper example this would be ((2 + 1 + 3 + 1)/4)/3 = 0.588
  This means that 58.8% of possible cell types are found per cluster on average.
  The lower, the better.
  The minimal value in this example would be 0.33.

- prop_cells_per_cluster_median = the proportion of cells per cluster that 
  belong to a specific cell type. As a score, the median of all these values 
  in the comparison value is calculated. 
  This only accounts for fields that are not 0.
  In this example, the score would be median(0.5, 0.5, 1, 0.33, 0.33, 0.33, 1)
  = 0.5
  
- prop_cells_per_cluster_mean = the same as above but calculating the mean, 
  not the median proportion.
  In this example, the score would be mean(0.5, 0.5, 1, 0.33, 0.33, 0.33, 1)
  = 0.5

```{r function_mat, include = FALSE}
calculate_scores_mat <- function(seu){
  
  seu <- seu 
  print(seu@misc$resolution)
  # seurat objects with clusters in "seurat_clusters" slot and
  # cell type or identity to compare in "cell_type" slot
  
  # make a comparison matrix, then split into cells/celltype and cells/cluster
  mat <- base::table(seu$cell_type, seu$seurat_clusters)
  mat_per_celltype <- mat/Matrix::rowSums(mat)
  t_mat <- t(mat)
  mat_per_cluster <- t(t_mat/Matrix::rowSums(t_mat)) # keep format

  #-----------------------------------------------------------------------------
  # score 1: proportions of 0
  
  # extract which nr is higher; nr of clusters or number of cell types  
  if(nrow(mat) >= ncol(mat)){
    max_nr <- nrow(mat)
  }else if(nrow(mat) < ncol(mat)){
    max_nr <- ncol(mat)
  }
  
  # get the proportion of fields that are 0 from the max possible nr of fields
  # that can be 0 in a theoretical perfect re-clustering. 
  # That "max possible nr" is equivalent to all fields - max_nr
  
  # if there is only one column = one cluster, the score has to be one
  if(ncol(mat) == 1){
    score_1 <- 1
  }else{
  
    score_1 <- length(which(mat == 0))/(ncol(mat)*nrow(mat)-max_nr)
    print(score_1)
    stopifnot(score_1 <= 1)
  } 
  #-----------------------------------------------------------------------------

  # test the mean or median of the proportions of cells of a cell type
  # that are in a new cluster

  # proportion of cells of a cell type per cluster
  mat_per_cluster_na <- mat_per_cluster
  mat_per_cluster_na[mat_per_cluster_na == 0] <- NA
  per_cluster_median <- stats::median(mat_per_cluster_na, na.rm = TRUE)
  per_cluster_mean <- base::mean(mat_per_cluster_na, na.rm = TRUE)
  
  score_2 <- per_cluster_median
  score_3 <- per_cluster_mean
 
  #-----------------------------------------------------------------------------
  # include ranking
  values <- c(mat_per_cluster)
  
  ranks <- base::rank(values, ties.method = "random")

  rank_df <- data.frame("values" = values,
                        "ranks" = ranks)

  rank_df <- rank_df[order(rank_df$ranks, decreasing = TRUE),]
  
  # take only top X% of rankings into account for calculating mean
  score_4 <- base::mean(rank_df$values[1:(base::round(nrow(rank_df)*cut_off_ranks, digits = 0))])

  #-----------------------------------------------------------------------------
  
  # test the nr of cell types per cluster and reverse
  nr_celltypes <- nrow(mat)
  nr_clusters <- ncol(mat)
  
  # nr of cell types per cluster
  nr_cts_per_cluster <- vector()
  for(i in 1:ncol(mat)){
    nr_cts_per_cluster <- c(nr_cts_per_cluster, length(which(mat[,i] != 0)))
    names(nr_cts_per_cluster)[i] <- colnames(nr_cts_per_cluster)[i]
  }
  score_5 <- base::mean(nr_cts_per_cluster)
  score_6 <- score_4/nr_celltypes # normalize by total number of cell types
  
  # nr of clusters per ct
  nr_clusters_per_ct <- vector()
  for(i in 1:nrow(mat)){
    nr_clusters_per_ct <- c(nr_clusters_per_ct, length(which(mat[i,] != 0)))
    names(nr_clusters_per_ct)[i] <- colnames(nr_clusters_per_ct)[i]
  }
  score_7 <- base::mean(nr_clusters_per_ct)
  score_8 <- score_6/nr_clusters # normalize by total number of clusters
  # score_7 and score_5 are identical
  
  return_df <- data.frame(
    "type" = c("prop_of_zeros", 
               "prop_cells_per_cluster_median", 
               "prop_cells_per_cluster_mean",
               "prop_cells_per_cluster_mean_ranked",
               "mean_ct_per_cluster",
               "mean_ct_per_cluster_norm",
               "mean_cluster_per_ct",
               "mean_cluster_per_ct_norm", 
               "total_nr_cluster", 
               "total_nr_ct"),
    "value" = c(score_1, 
                score_2,
                score_3,
                score_4,
                score_5, 
                score_6,
                score_7, 
                score_8,
                nr_clusters, 
                nr_celltypes)
  )
    
  return_df$nr_recl <- base::rep(length(base::unique(seu$seurat_clusters)))
  return_df$resolution <- base::rep(seu@misc$resolution)
  return(return_df)
}

```

```{r mat_df, include = FALSE}
df_list_mat <- lapply(seu_list_all, function(seu_list){
  
  res_mat_list <- lapply(seu_list, calculate_scores_mat)
  
  df_mat <- dplyr::bind_rows(res_mat_list)
  
  gene_set_used <- seu_list[[1]]@misc$used_genes[1]
  print(gene_set_used)
  df_mat$conservation_level <- base::rep(
    gene_set_used, 
    nrow(df_mat))
  df_mat$length_conservation_level <- base::rep(
    length(seu_list[[1]]@misc$all_features_subclustering), 
    nrow(df_mat))
  
  return(df_mat)
})
  
df_mat <- dplyr::bind_rows(df_list_mat)
head(df_mat)
```

```{r mat_df_plotfunction, include = FALSE}
mat_plots <- lapply(df_list_mat, function(df_mat){
  
  df_mat_short <- df_mat[df_mat$type %in% c(
    "prop_of_zeros", 
    "prop_cells_per_cluster_median", 
    "prop_cells_per_cluster_mean",
    "prop_cells_per_cluster_mean_ranked",
    "mean_ct_per_cluster_norm"),]
  
  title <- base::paste(df_mat$length_conservation_level[1],
                       df_mat$conservation_level[1], 
                       dataset_curr)
  
  plot1 <- ggplot2::ggplot(
    df_mat_short,
    aes(x = nr_recl, y = value, color = type))+
    ggplot2::geom_point(alpha = 0.7)+
    ggplot2::theme_classic()+
    ggplot2::scale_color_manual("score type", values = col_vec1)+
    ggplot2::ylim(c(0, 1))+
    ggplot2::ggtitle(title)+
    ggplot2::xlim(0, max(df_mat_short$nr_recl))
  
  plot2 <- ggplot2::ggplot(
    df_mat_short,
    aes(x = resolution, y = value, color = type))+
    ggplot2::geom_point(alpha = 0.7)+
    ggplot2::theme_classic()+
    ggplot2::scale_color_manual("score type", values = col_vec1)+
    ggplot2::ylim(c(0, 1))+
    ggplot2::ggtitle(title)

  df_mat_shorter <- df_mat[df_mat$type %in% c(
    "mean_ct_per_cluster", 
    "mean_cluster_per_ct",
    "total_nr_cluster"),]
  
  plot3 <- ggplot2::ggplot(
    df_mat_shorter,
    aes(x = nr_recl, y = value, color = type))+
    ggplot2::geom_point(alpha = 0.7)+
    ggplot2::theme_classic()+
    ggplot2::scale_color_manual("score type", values = col_vec2)+
    ggplot2::geom_hline(yintercept = df_mat$value[df_mat == "total_nr_ct"][1],
                        color = "grey20", 
                        linetype = "dashed")+
    ggplot2::ggtitle(title)+
    ggplot2::xlim(0, max(df_mat_shorter$nr_recl))+
    ggplot2::ylim(0, max(c(df_mat_shorter$value), 
                         df_mat$value[df_mat == "total_nr_ct"][1]))
  
  plot4 <- ggplot2::ggplot(
    df_mat_shorter,
    aes(x = resolution, y = value, color = type))+
    ggplot2::geom_point(alpha = 0.7)+
    ggplot2::theme_classic()+
    ggplot2::scale_color_manual("score type", values = col_vec2)+
    ggplot2::geom_hline(yintercept = df_mat$value[df_mat == "total_nr_ct"][1],
                        color = "grey20", 
                        linetype = "dashed")+
    ggplot2::ggtitle(title)+
    ggplot2::ylim(0, max(c(df_mat_shorter$value), 
                         df_mat$value[df_mat == "total_nr_ct"][1]))
  
  return(list(plot1, plot2, plot3, plot4))
})
```

```{r mat_plots, fig.height = 3, fig.width = 7}
mat_plots
```

```{r get_hist_function, fig.height = 4, fig.width = 4}
get_hist <- function(seu){
  
  seu <- seu 
  # seurat objects with clusters in "seurat_clusters" slot and
  # cell type or identity to compare in "cell_type" slot
  
  title <- base::paste(seu@misc$resolution, 
                       dataset_curr,
                       length(base::unique(seu$seurat_clusters)),
                       "clusters")
  
  # make a comparison matrix, then split into cells/celltype and cells/cluster
  mat <- base::table(seu$cell_type, seu$seurat_clusters)
  t_mat <- t(mat)
  mat_per_cluster <- t(t_mat/Matrix::rowSums(t_mat)) # keep format
  
  all_values <- c(mat_per_cluster)
  nonzero_values <- c(mat_per_cluster[mat_per_cluster != 0])
  
  plot <- ggplot2::ggplot(data.frame("values" = all_values), 
                          aes(x = all_values))+
    ggplot2::geom_histogram(binwidth = 0.01)+
    ggplot2::theme_classic()+
    ggplot2::ggtitle(title)
    
  return(plot)
}
```

```{r hist_sign, fig.height = 24, fig.width = 12}
plot_list <- lapply(seu_list_all$seu_sign, get_hist)
cowplot::plot_grid(
  ncol = 3,
  plotlist = plot_list)
```

```{r hist_mark, fig.height = 24, fig.width = 12}
plot_list <- lapply(seu_list_all$seu_mark, get_hist)
cowplot::plot_grid(
  ncol = 3,
  plotlist = plot_list)
```

```{r hist_mmms, fig.height = 24, fig.width = 12}
plot_list <- lapply(seu_list_all$seu_mmms, get_hist)
cowplot::plot_grid(
  ncol = 3,
  plotlist = plot_list)
```

```{r hist_rand, fig.height = 24, fig.width = 12}
plot_list <- lapply(seu_list_all$seu_rand, get_hist)
cowplot::plot_grid(
  ncol = 3,
  plotlist = plot_list)
```

```{r mat_plots_all, fig.height = 3, fig.width = 7}

plot1 <- ggplot2::ggplot(
  df_mat[df_mat$type == "prop_of_zeros",],
  aes(x = nr_recl, y = value, color = conservation_level))+
  ggplot2::geom_point(alpha = 0.7)+
  ggplot2::geom_line()+
  ggplot2::theme_classic()+
  ggplot2::scale_color_manual("conservation level", values = col_vec_cons)+
  ggplot2::ggtitle(base::paste(dataset_curr, "prop_of_zeros"))+
  ggplot2::ylim(c(0,1))+
  ggplot2::xlim(0, max(df_mat$nr_recl))
plot1

plot2 <- ggplot2::ggplot(
  df_mat[df_mat$type == "prop_cells_per_cluster_median",],
  aes(x = nr_recl, y = value, color = conservation_level))+
  ggplot2::geom_point(alpha = 0.7)+
  ggplot2::geom_line()+
  ggplot2::theme_classic()+
   ggplot2::scale_color_manual("conservation level", values = col_vec_cons)+
  ggplot2::ggtitle(base::paste(dataset_curr, "prop_cells_per_cluster_median"))+
  ggplot2::ylim(c(0,1))+
  ggplot2::xlim(0, max(df_mat$nr_recl))
plot2

plot3 <- ggplot2::ggplot(
  df_mat[df_mat$type == "prop_cells_per_cluster_mean",],
  aes(x = nr_recl, y = value, color = conservation_level))+
  ggplot2::geom_point(alpha = 0.7)+
  ggplot2::geom_line()+
  ggplot2::theme_classic()+
  ggplot2::scale_color_manual("conservation level", values = col_vec_cons)+
  ggplot2::ggtitle(base::paste(dataset_curr, "prop_cells_per_cluster_mean"))+
  ggplot2::ylim(c(0,1))+
  ggplot2::xlim(0, max(df_mat$nr_recl))
plot3

plot4 <- ggplot2::ggplot(
  df_mat[df_mat$type == "prop_cells_per_cluster_mean_ranked",],
  aes(x = nr_recl, y = value, color = conservation_level))+
  ggplot2::geom_point(alpha = 0.7)+
  ggplot2::geom_line()+
  ggplot2::theme_classic()+
  ggplot2::scale_color_manual("conservation level", values = col_vec_cons)+
  ggplot2::ggtitle(base::paste(dataset_curr, 
                               "prop_cells_per_cluster_mean_ranked"))+
  ggplot2::ylim(c(0,1))+
  ggplot2::xlim(0, max(df_mat$nr_recl))
plot4

plot5 <- ggplot2::ggplot(
  df_mat[df_mat$type == "mean_ct_per_cluster_norm",],
  aes(x = nr_recl, y = value, color = conservation_level))+
  ggplot2::geom_point(alpha = 0.7)+
  ggplot2::geom_line()+
  ggplot2::theme_classic()+
  ggplot2::scale_color_manual("conservation level", values = col_vec_cons)+
  ggplot2::ggtitle(base::paste(dataset_curr, "mean_ct_per_cluster_norm"))+
  ggplot2::ylim(c(0,1))+
  ggplot2::xlim(0, max(df_mat$nr_recl))
plot5
```

```{r mat_plots_all_resolution, fig.height = 3, fig.width = 7}
plot1 <- ggplot2::ggplot(
  df_mat[df_mat$type == "prop_of_zeros",],
  aes(x = resolution, y = value, color = conservation_level))+
  ggplot2::geom_point(alpha = 0.7)+
  ggplot2::geom_line()+
  ggplot2::theme_classic()+
  ggplot2::scale_color_manual("conservation level", values = col_vec_cons)+
  ggplot2::ggtitle(base::paste(dataset_curr, "prop_of_zeros"))+
  ggplot2::ylim(c(0,1))
plot1

plot2 <- ggplot2::ggplot(
  df_mat[df_mat$type == "prop_cells_per_cluster_median",],
  aes(x = resolution, y = value, color = conservation_level))+
  ggplot2::geom_point(alpha = 0.7)+
  ggplot2::geom_line()+
  ggplot2::theme_classic()+
   ggplot2::scale_color_manual("conservation level", values = col_vec_cons)+
  ggplot2::ggtitle(base::paste(dataset_curr, "prop_cells_per_cluster_median"))+
  ggplot2::ylim(c(0,1))
plot2

plot3 <- ggplot2::ggplot(
  df_mat[df_mat$type == "prop_cells_per_cluster_mean",],
  aes(x = resolution, y = value, color = conservation_level))+
  ggplot2::geom_point(alpha = 0.7)+
  ggplot2::geom_line()+
  ggplot2::theme_classic()+
  ggplot2::scale_color_manual("conservation level", values = col_vec_cons)+
  ggplot2::ggtitle(base::paste(dataset_curr, "prop_cells_per_cluster_mean"))+
  ggplot2::ylim(c(0,1))
plot3

plot4 <- ggplot2::ggplot(
  df_mat[df_mat$type == "prop_cells_per_cluster_mean_ranked",],
  aes(x = resolution, y = value, color = conservation_level))+
  ggplot2::geom_point(alpha = 0.7)+
  ggplot2::geom_line()+
  ggplot2::theme_classic()+
  ggplot2::scale_color_manual("conservation level", values = col_vec_cons)+
  ggplot2::ggtitle(base::paste(dataset_curr,
                               "prop_cells_per_cluster_mean_ranked"))+
  ggplot2::ylim(c(0,1))
plot4

plot5 <- ggplot2::ggplot(
  df_mat[df_mat$type == "mean_ct_per_cluster_norm",],
  aes(x = resolution, y = value, color = conservation_level))+
  ggplot2::geom_point(alpha = 0.7)+
  ggplot2::geom_line()+
  ggplot2::theme_classic()+
  ggplot2::scale_color_manual("conservation level", values = col_vec_cons)+
  ggplot2::ggtitle(base::paste(dataset_curr, "mean_ct_per_cluster_norm"))+
  ggplot2::ylim(c(0,1))
plot5
```

### Scores from cluster silhouette and purity 

Using cluster silhuoette and cluster purity to evaluate the re-clustered
populations.
This does not compare to the original clusters at all.
This just evaluates the re-clustering quality independent of the original cell
types.

- cluster silhouette: "measure of how similar an object is to its own cluster 
  (cohesion) compared to other clusters (separation)". "A clustering with an
  average silhouette width of over 0.7 is considered to be "strong",
  a value over 0.5 "reasonable" and over 0.25 "weak" "
  https://en.wikipedia.org/wiki/Silhouette_(clustering)
  
- cluster purity: "measure of the extent to which clusters contain a single 
  class", "more clusters will make it easier to produce a high purity."
  https://en.wikipedia.org/wiki/Cluster_analysis
  
```{r sp_function}

calculate_scores_sil_pur <- function(seu){
  
  seu <- seu

  #-----------------------------------------------------------------------------
  # test the silhuoette width compared 

  dist.matrix_recl <- stats::dist(x = SeuratObject::Embeddings(
    object = seu[["pca"]])) 
  clusters_recl <- seu$seurat_clusters
  sil_recl <- cluster::silhouette(
    x = as.numeric(x = as.factor(x = clusters_recl)), 
    dist = dist.matrix_recl)
  seu$sil_recl <- sil_recl[,3]  
  
  score_1 <- stats::median(seu$sil_recl)
  score_2 <- base::mean(seu$sil_recl)
  
  #-----------------------------------------------------------------------------
  # test the relative purity compared to original clustering

  # re-clustered purity
  # default options, 10PCs, k = 50
  mat_recl <- seu@reductions$pca@cell.embeddings[,1:10]
  res_recl <- bluster::neighborPurity(mat_recl, 
                                      clusters = seu$seurat_clusters, 
                                      k = 50)
  seu$purity <- res_recl$purity  

  score_3 <- stats::median(seu$purity)
  score_4 <- base::mean(seu$purity)
  
  return_df <- data.frame(
    "type" = c("median_silhouette_width",
               "mean_silhouette_width",
               "median_purity",
               "mean_purity"),
    "value" = c(score_1, 
                score_2,
                score_3,
                score_4)
  )

  return_df$nr_recl <- base::rep(length(base::unique(seu$seurat_clusters)))
  return_df$resolution <- base::rep(seu@misc$resolution)
  return(return_df)
}  

```

```{r sp_df}
df_list_sp <- lapply(seu_list_all, function(seu_list){
  
  res_sp <- lapply(seu_list, calculate_scores_sil_pur)
  
  df_sp <- dplyr::bind_rows(res_sp)
  
  gene_set_used <- seu_list[[1]]@misc$used_genes[1]
  print(gene_set_used)
  
  df_sp$conservation_level <- base::rep(
    gene_set_used, 
    nrow(df_sp))
  df_sp$length_conservation_level <- base::rep(
    length(seu_list[[1]]@misc$all_features_subclustering), 
    nrow(df_sp))
  
  return(df_sp)
})
  
df_sp <- dplyr::bind_rows(df_list_sp)
head(df_sp)
```

```{r sp_df_plotfunction, fig.height = 3, fig.width = 7}
sp_plots <- lapply(df_list_sp, function(df_sp){
  
  title <- base::paste(df_sp$length_conservation_level[1],
                       df_sp$conservation_level[1], 
                       dataset_curr)

  plot1 <- ggplot2::ggplot(
    df_sp,
    aes(x = nr_recl, y = value, color = type))+
    ggplot2::geom_point(alpha = 0.7)+
    ggplot2::theme_classic()+
    ggplot2::scale_color_manual("score type", values = col_vec3)+
    ggplot2::ggtitle(title)+
    ggplot2::geom_hline(yintercept = 0.25,
                        linetype = "dashed")+
    ggplot2::ylim(c(-1, 1))+
    ggplot2::xlim(0, max(df_sp$nr_recl))
  
  plot2 <- ggplot2::ggplot(
    df_sp,
    aes(x = resolution, y = value, color = type))+
    ggplot2::geom_point(alpha = 0.7)+
    ggplot2::theme_classic()+
    ggplot2::scale_color_manual("score type", values = col_vec3)+
    ggplot2::ggtitle(title)+
    ggplot2::ylim(c(-1, 1))+
    ggplot2::geom_hline(yintercept = 0.25,
                        linetype = "dashed")

  return(list(plot1, plot2))
})
```

```{r fig.height = 3, fig.width = 7}
sp_plots
```

```{r sp_all_recl, fig.height = 3, fig.width = 7}
plot1 <- ggplot2::ggplot(
    df_sp[df_sp$type == "median_silhouette_width",],
    aes(x = nr_recl, y = value, color = conservation_level))+
    ggplot2::geom_point(alpha = 0.7)+
    ggplot2::geom_line()+
    ggplot2::theme_classic()+
    ggplot2::scale_color_manual("conservation level", values = col_vec_cons)+
    ggplot2::ggtitle(base::paste(dataset_curr, "median_silhouette_width"))+
    ggplot2::ylim(c(-1, 1))+
    ggplot2::xlim(0, max(df_sp$nr_recl))
plot1

plot2 <- ggplot2::ggplot(
    df_sp[df_sp$type == "mean_silhouette_width",],
    aes(x = nr_recl, y = value, color = conservation_level))+
    ggplot2::geom_point(alpha = 0.7)+
    ggplot2::geom_line()+
    ggplot2::theme_classic()+
    ggplot2::scale_color_manual("conservation level", values = col_vec_cons)+
    ggplot2::ggtitle(base::paste(dataset_curr, "mean_silhouette_width"))+
    ggplot2::ylim(c(-1, 1))+
    ggplot2::xlim(0, max(df_sp$nr_recl))
plot2

plot3 <- ggplot2::ggplot(
    df_sp[df_sp$type == "median_purity",],
    aes(x = nr_recl, y = value, color = conservation_level))+
    ggplot2::geom_point(alpha = 0.7)+
    ggplot2::geom_line()+
    ggplot2::theme_classic()+
    ggplot2::scale_color_manual("conservation level", values = col_vec_cons)+
    ggplot2::ggtitle(base::paste(dataset_curr, "median_purity"))+
    ggplot2::xlim(0, max(df_sp$nr_recl))+
    ggplot2::ylim(c(0, 1))
plot3

plot4 <- ggplot2::ggplot(
    df_sp[df_sp$type == "mean_purity",],
    aes(x = nr_recl, y = value, color = conservation_level))+
    ggplot2::geom_point(alpha = 0.7)+
    ggplot2::geom_line()+
    ggplot2::theme_classic()+
    ggplot2::scale_color_manual("conservation level", values = col_vec_cons)+
    ggplot2::ggtitle(base::paste(dataset_curr, "mean_purity"))+
    ggplot2::xlim(0, max(df_sp$nr_recl))+
    ggplot2::ylim(c(0, 1))
plot4
```

```{r sp_all_resolution}
plot1 <- ggplot2::ggplot(
    df_sp[df_sp$type == "median_silhouette_width",],
    aes(x = resolution, y = value, color = conservation_level))+
    ggplot2::geom_point(alpha = 0.7)+
    ggplot2::geom_line()+
    ggplot2::theme_classic()+
    ggplot2::scale_color_manual("conservation level", values = col_vec_cons)+
    ggplot2::ggtitle(base::paste(dataset_curr, "median_silhouette_width"))+
    ggplot2::ylim(c(-1, 1))
plot1

plot2 <- ggplot2::ggplot(
    df_sp[df_sp$type == "mean_silhouette_width",],
    aes(x = resolution, y = value, color = conservation_level))+
    ggplot2::geom_point(alpha = 0.7)+
    ggplot2::geom_line()+
    ggplot2::theme_classic()+
    ggplot2::scale_color_manual("conservation level", values = col_vec_cons)+
    ggplot2::ggtitle(base::paste(dataset_curr, "mean_silhouette_width"))+
    ggplot2::ylim(c(-1, 1))
plot2

plot3 <- ggplot2::ggplot(
    df_sp[df_sp$type == "median_purity",],
    aes(x = resolution, y = value, color = conservation_level))+
    ggplot2::geom_point(alpha = 0.7)+
    ggplot2::geom_line()+
    ggplot2::theme_classic()+
    ggplot2::scale_color_manual("conservation level", values = col_vec_cons)+
    ggplot2::ggtitle(base::paste(dataset_curr, "median_purity"))+
    ggplot2::ylim(c(0, 1))
plot3

plot4 <- ggplot2::ggplot(
    df_sp[df_sp$type == "mean_purity",],
    aes(x = resolution, y = value, color = conservation_level))+
    ggplot2::geom_point(alpha = 0.7)+
    ggplot2::geom_line()+
    ggplot2::theme_classic()+
    ggplot2::scale_color_manual("conservation level", values = col_vec_cons)+
    ggplot2::ggtitle(base::paste(dataset_curr, "mean_purity"))+
    ggplot2::ylim(c(0, 1))
plot4
```

### Scores metrics for clustering comparison

Trying three different established metrics to compare two clusterings

- Adjusted Rand Index

- Fowlkes-Mallows index

- Variation of Information

```{r function_metrics}
calculate_scores_metrics <- function(seu){
  
  seu <- seu 
  
  # adjusted rand index
  val1 <- mclust::adjustedRandIndex(seu$seurat_clusters, seu$cell_type)
  
  # fowlkesMallowsIndex
  #val2 <- dendextend::FM_index_R(seu$cell_type, seu$seurat_clusters)[1]
  # cannot be tested anymore because I didn't install dendextend into 
  # the latest env
  
  # variation of information
  # Larger values of the distance metric correspond to greater 
  # dissimilarity between the clusterings. 
  val3 <- vi.dist(seu$cell_type, seu$seurat_clusters)
  
  #val2 <- partitionComparison::compareAll(partition_orig, partition_recl)
  return_df <- data.frame(
    "type" = c("adj_rand", 
               "variation_information"),
    "value" = c(val1,
                #val2,
                val3),
    "nr_recl" = length(base::unique(seu$seurat_clusters))
  )
  return_df$resolution <- rep(seu@misc$resolution)
  return(return_df)
}
```

```{r metdf}
df_list_met <- lapply(seu_list_all, function(seu_list){
  
  res_met <- lapply(seu_list, calculate_scores_metrics)
  
  df_met <- dplyr::bind_rows(res_met)
  
  gene_set_used <- seu_list[[1]]@misc$used_genes[1]
  print(gene_set_used)
  
  df_met$conservation_level <- base::rep(
    gene_set_used, 
    nrow(df_met))
  
  df_met$length_conservation_level <- base::rep(
    length(seu_list[[1]]@misc$all_features_subclustering), 
    nrow(df_met))
  
  
  return(df_met)
})
  
df_met <- dplyr::bind_rows(df_list_met)
head(df_met)
```

```{r metplotslist}
met_plots <- lapply(df_list_met, function(df_met){
  
  title <- base::paste(df_met$length_conservation_level[1],
                       df_met$conservation_level[1], 
                       ",",
                       dataset_curr)
  
  plot1 <- ggplot2::ggplot(
    df_met,
    aes(x = nr_recl, y = value, color = type))+
    ggplot2::geom_point(alpha = 0.7)+
    ggplot2::theme_classic()+
    ggplot2::scale_color_manual("score type", values = col_vec4)+
    ggplot2::ggtitle(title)+
    ggplot2::xlim(0, max(df_met$nr_recl))+
    ggplot2::ylim(0, max(df_met$value))
  
  plot2 <- ggplot2::ggplot(
    df_met,
    aes(x = resolution, y = value, color = type))+
    ggplot2::geom_point(alpha = 0.7)+
    ggplot2::theme_classic()+
    ggplot2::scale_color_manual("score type", values = col_vec4)+
    ggplot2::ggtitle(title)+
    ggplot2::ylim(0, max(df_met$value))
  
  return(list(plot1, plot2))
})
```

```{r metplots1, fig.height = 3, fig.width = 7}
met_plots
```

```{r met_all_recl, fig.height = 3, fig.width = 7}
plot1 <- ggplot2::ggplot(
    df_met[df_met$type == "adj_rand",],
    aes(x = nr_recl, y = value, color = conservation_level))+
    ggplot2::geom_point(alpha = 0.7)+
    ggplot2::geom_line()+
    ggplot2::theme_classic()+
    ggplot2::scale_color_manual("conservation level", values = col_vec_cons)+
    ggplot2::ggtitle(base::paste(dataset_curr, "adj_rand"))+
    ggplot2::xlim(0, max(df_met$nr_recl))+
    ggplot2::ylim(0, 1)
plot1

plot2 <- ggplot2::ggplot(
    df_met[df_met$type == "fowlkes_mallows",],
    aes(x = nr_recl, y = value, color = conservation_level))+
    ggplot2::geom_point(alpha = 0.7)+
    ggplot2::geom_line()+
    ggplot2::theme_classic()+
    ggplot2::scale_color_manual("conservation level", values = col_vec_cons)+
    ggplot2::ggtitle(base::paste(dataset_curr, "fowlkes_mallows"))+
    ggplot2::xlim(0, max(df_met$nr_recl))+
    ggplot2::ylim(0, 1)
plot2

plot3 <- ggplot2::ggplot(
    df_met[df_met$type == "variation_information",],
    aes(x = nr_recl, y = value, color = conservation_level))+
    ggplot2::geom_point(alpha = 0.7)+
    ggplot2::geom_line()+
    ggplot2::theme_classic()+
    ggplot2::scale_color_manual("conservation level", values = col_vec_cons)+
    ggplot2::ggtitle(base::paste(dataset_curr, "variation_information"))+
    ggplot2::xlim(0, max(df_met$nr_recl))+
    ggplot2::ylim(0, max(df_met$value))
plot3
```

```{r met_all_resolution, fig.height = 3, fig.width = 7}
plot1 <- ggplot2::ggplot(
    df_met[df_met$type == "adj_rand",],
    aes(x = resolution, y = value, color = conservation_level))+
    ggplot2::geom_point(alpha = 0.7)+
    ggplot2::geom_line()+
    ggplot2::theme_classic()+
    ggplot2::scale_color_manual("conservation level", values = col_vec_cons)+
    ggplot2::ggtitle(base::paste(dataset_curr, "adj_rand"))+
    ggplot2::ylim(0, 1)
plot1

plot2 <- ggplot2::ggplot(
    df_met[df_met$type == "fowlkes_mallows",],
    aes(x = resolution, y = value, color = conservation_level))+
    ggplot2::geom_point(alpha = 0.7)+
    ggplot2::geom_line()+
    ggplot2::theme_classic()+
    ggplot2::scale_color_manual("conservation level", values = col_vec_cons)+
    ggplot2::ggtitle(base::paste(dataset_curr, "fowlkes_mallows"))+
    ggplot2::ylim(0, 1)
plot2

plot3 <- ggplot2::ggplot(
    df_met[df_met$type == "variation_information",],
    aes(x = resolution, y = value, color = conservation_level))+
    ggplot2::geom_point(alpha = 0.7)+
    ggplot2::geom_line()+
    ggplot2::theme_classic()+
    ggplot2::scale_color_manual("conservation level", values = col_vec_cons)+
    ggplot2::ggtitle(base::paste(dataset_curr, "variation_information"))+
    ggplot2::ylim(0, max(df_met$value))
plot3
```

Based on this report, we use as reclustering scores:

 - mean proportion of cells of a cell type per cluster (ranked)
 - adjusted rand index
 - variation of information
 
We also use mean cluster purity to help select the optimal resolution.

```{r sessioninfo}
utils::sessionInfo()
```
